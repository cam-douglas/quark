#!/usr/bin/env python3
"""Pre-push maintenance script (invoked by `.git/hooks/pre-push`).

Current responsibilities
========================
1. **Regenerate `master_roadmap.md`** â€“ scan every Markdown roadmap under
   `management/rules/roadmap/`, extract their top-level headings, and write a
   single canonical *master* file containing bullet-link entries for each
   document.  This guarantees the master file is always in sync after renames
   or title changes.

2. **Validate internal links** â€“ fast check that all relative links inside
   `master_roadmap.md` resolve; abort push on breakage.

3. **Sync YAML task DB** â€“ call `state.quark_state_system.task_loader` to align
   roadmap tasks with the YAML task store.

4. **Refresh README status** â€“ update the Roadmap Status block in the root
   `README.md`.

The script exits non-zero to block the push if link validation fails or if an
unexpected exception occurs.
"""
from __future__ import annotations
import subprocess as sp
import sys
from pathlib import Path
import re
import textwrap
import datetime

ROOT = Path(__file__).resolve().parents[2]  # project root
RD_DIR = ROOT / "management" / "rules" / "roadmap"
MASTER = RD_DIR / "MASTER_ROADMAP.md"
README = ROOT / "README.md"


# ---------------------------------------------------------------------------
# Util helpers
# ---------------------------------------------------------------------------

def log(msg: str):
    print(f"[pre-push] {msg}")


def run(cmd):
    log("$ " + " ".join(cmd))
    sp.run(cmd, check=True)


# ---------------------------------------------------------------------------
# 1. Build / refresh master_roadmap.md from individual roadmap files
# ---------------------------------------------------------------------------


def build_master_roadmap():  # noqa: D401
    """Auto-generate *master_roadmap.md* that links to all roadmap docs.

    Logic:
    1. Enumerate all Markdown files in the roadmap directory (excluding the
       master files themselves).
    2. Extract the first Markdown heading ("# Heading") from each file to use
       as the link title.  Fallback to the filename stem.
    3. Overwrite *master_roadmap.md* with a simple list of bullet links.
    """

    header = "# ðŸš€ Quark Project Roadmaps\n\n_Autogenerated by pre_push_update.py â€“ do not edit manually._\n\n"
    items = []
    for fp in sorted(RD_DIR.glob("*.md")):
        # Skip the master snapshot files themselves
        if fp.name.lower().startswith("master"):
            continue

        title = fp.stem.replace("_", " ").title()
        for line in fp.read_text(encoding="utf-8", errors="ignore").splitlines():
            if line.lstrip().startswith("#"):
                title = line.lstrip("# ").strip()
                break
        rel_path = fp.name  # relative to RD_DIR
        items.append(f"* [{title}]({rel_path})")

    content = header + "\n".join(items) + "\n"
    MASTER.write_text(content, encoding="utf-8")
    log("master_roadmap.md regenerated from individual roadmap files")


# ---------------------------------------------------------------------------
# 2. Link validation for master roadmap
# ---------------------------------------------------------------------------

link_pat = re.compile(r"\[([^\]]+)\]\(([^)]+)\)")

def validate_links():
    broken = []
    for match in link_pat.finditer(MASTER.read_text(encoding="utf-8", errors="ignore")):
        target = match.group(2)
        # skip external URLs
        if target.startswith("http"):
            continue
        path = (MASTER.parent / target).resolve() if not Path(target).is_absolute() else ROOT / target
        if not path.exists():
            broken.append(target)
    if broken:
        log("Broken links found:")
        for b in broken:
            print(" -", b)
        sys.exit(1)


# ---------------------------------------------------------------------------
# 3. Sync roadmap snapshot â†’ YAML tasks
# ---------------------------------------------------------------------------

def sync_tasks():
    from management.rules.roadmap.roadmap_controller import status_snapshot
    from state.quark_state_system import task_loader
    before = len(list(task_loader.get_tasks()))
    task_loader.sync_with_roadmaps(status_snapshot())
    # granular tasks from master roadmap (function not implemented yet)
    # master = RD_DIR / "master_roadmap.md"
    # added = task_loader.generate_tasks_from_master(master)
    added = 0  # placeholder until function is implemented
    after = len(list(task_loader.get_tasks()))
    log(f"Tasks synced (before={before}, after={after}, added_from_master={added})")


# 5. Brain directory indexing (neural-core & ML modules)

from glob import glob
import json

BRAIN_MANIFEST = ROOT / "brain_manifest.json"
REPO_MANIFEST = ROOT / "repo_index.json"

def build_brain_manifest():
    """Scan brain/**/*.py and update manifest JSON files."""
    patterns = [str(ROOT / "brain" / "**" / "*.py"), str(ROOT / "brain" / "**" / "*.pyi")]
    files = []
    for pat in patterns:
        files.extend(glob(pat, recursive=True))
    files = [str(Path(f).resolve().relative_to(ROOT)) for f in sorted(files)]
    BRAIN_MANIFEST.write_text(json.dumps(files, indent=2))
    REPO_MANIFEST.write_text(json.dumps(files, indent=2))
    log(f"Brain manifest updated with {len(files)} python files")


# ---------------------------------------------------------------------------
# 4. README update
# ---------------------------------------------------------------------------

START_TAG = "<!-- ROADMAP_STATUS_START -->"
END_TAG = "<!-- ROADMAP_STATUS_END -->"

def roadmap_summary() -> str:
    from management.rules.roadmap.roadmap_controller import status_snapshot
    snap = status_snapshot()
    done = sum(1 for s in snap.values() if s == "done")
    progress = sum(1 for s in snap.values() if s == "progress")
    planned = sum(1 for s in snap.values() if s == "planned")
    from importlib import import_module
    task_loader = import_module('state.quark_state_system.task_loader')
    pending_tasks = sum(1 for _ in task_loader.get_tasks(status="pending"))
    abstract = textwrap.dedent(f"""
    **Roadmap Status**  
    Date: {datetime.date.today()}  
    Roadmaps: {len(snap)} (âœ… {done} Â· ðŸš§ {progress} Â· ðŸ“‹ {planned})  
    Pending tasks: {pending_tasks}
    """).strip()
    bullets = """\
* Use `python QUARK_STATE_SYSTEM.py \\"update roadmap\\"` after editing roadmap files.  
* Top priorities surfaced via `recommendations` command.  
* Chat-specified tasks live in `chat_tasks.yaml`.
"""
    return abstract + "\n\n" + bullets


def update_readme():
    rd_text = README.read_text(encoding="utf-8")
    if START_TAG not in rd_text:
        rd_text += f"\n\n{START_TAG}\n{END_TAG}\n"
    new_block = roadmap_summary()
    rd_text = re.sub(f"{START_TAG}.*?{END_TAG}", f"{START_TAG}\n{new_block}\n{END_TAG}", rd_text, flags=re.S)
    README.write_text(rd_text, encoding="utf-8")
    log("README roadmap status updated")


# ---------------------------------------------------------------------------
# Entry
# ---------------------------------------------------------------------------

def main():
    try:
        build_master_roadmap()
        validate_links()
        sync_tasks()
        build_brain_manifest()
        update_readme()
        log("Pre-push update completed successfully âœ…")
    except Exception as e:  # pragma: no cover
        log(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
